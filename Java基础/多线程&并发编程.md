# 参考资料
1. [常见框架单例、多例与线程安全性总结](https://blog.csdn.net/kinglyjn/article/details/53666577)
2. 《Java并发编程的艺术》 方腾飞

# 一、多例和单例的线程安全性分析

**线程安全**问题是指: **多个用户****同时**在访问**同一个程序时**，其对于某一数据的修改，**会不会影响到其他用户中的该数据**。若没有影响，则是线程安全的;若有可能影响，则是线程不安全的。

1. **HttpServlet**

单例——即无论多少用户访问同一个业务，如 LoginServlet，Web 容器只会创建一个该 Servlet 实例。而该实例是允许多用户访问的。

若 Servlet 中包含成员变量，则每个用户对于成员变量的修改，均会影响到其他用户所看到的该变量的值，所以这时是线程不安全的。若不包含成员变量，则是线程安全的。

2. **HttpSession**

多例——Web 容器会为每个用户开辟一个 Session，多个用户会有多个 Session。而每个用户只能访问自己的 Session。所以，对于 Session 来说，就不存在并发访问的情况，也就不存在线程安全的问题了。所以可以说是线程安全的。

3. SpingMVC **Controller**
Spring MVC Controller**默认是单例**的：
单例的原因有二：
1、为了性能。
2、不需要多例。
如果需要多例，则需要在Controller类上加注解 @Scope(“prototype”)

4. Struts2 的 **Action**

**多例的**——对于同一个业务，例如 LoginAction，系统会为每一个用户创建一个LoginAction 的实例，并使其成员变量 username 与 password 接收用户 交的数据。同一用户只能访问自己的 Action。所以，对于 Action 来说，就不存在并发访问的情况，也就不存在线程安全的问题了。所以可以说是线程安全的。 

5. Hibernate 的**SessionFactory**

单例——无论多少用户访问该项目，系统只会创建一个 SessionFactory 对象，即这个对象是可以被所有用户访问的。

SessionFactory实现类中所包含的成员变量基本都是 final常量，即任何用户均不能修改。所以，也就不存在用户的修改对其他用户的影响问题了，所以是线程安全的。 

6. Hibernate 的 **Session**

**多例**——系统会为每个用户创建一个 Session。

Session 的实现类中定义了很多的非 final 成员变量，一个事务对成员变量所做的修改，会影响到另一个事务对同一数据的访问结果，所以是线程不安全的。

# 二、并发编程的挑战

* 上下文切换（时间片轮转，需要保存状态-恢复状态）
  > **如何减少上下文切换**？
  >1. 无锁并发编程；
  >2. CAS算法
  >3. 使用最少线程
  >4. 协程
* 死锁
  > **如何避免死锁**？
  > 1. 避免一个线程同时获取多个锁
  > 2. 避免一个线程在锁内同时占用多个资源，尽量保证一个锁占用一个资源
  > 3. 尝试使用定时锁，使用lock.tryLock(timeout)来代替使用内部锁
  > 4. 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会解锁失败。

* 资源限制的挑战 （带宽受限，CPU处理速度、磁盘读写速度）
  > 1. **引发的问题**：并发变串行，无端增加了上下文切换消耗，反而更慢了。
  > 2. **如何解决** ：多机集群，通过“数据ID mod 机器数”，分配对应机器处理；复用链接，连接池，调用接口获取数据。

# 并发机制的底层实现原理

**依赖于JVM的实现和CPU指令。**

## volatile的应用
轻量级的`synchronized`。

- 确保所有线程看到被其声明的变量的值是一致的。
- 汇编指令会多一个`lock`修饰，会在多核处理器引发两件事情：
  > 1. 将当前处理器缓存行的数据写回到系统内存。2. 这个写回操作会使其他CPU里缓存了该内存地址的数据无效。（通过嗅探来发现是否被修改。）
- 通过追加字节优化并发包里面的一个队列出队和入队的性能。（系统的字节宽度是固定的）在共享变量被频繁写时有用。

## synchronized
以前称呼它为 **重量级锁**。后来引入偏向锁、轻量级锁，以及锁的存储结构和升级过程。

  1. 锁的对象？
   - 普通同步方法——锁是 **当前实例对象**。
   - **静态**同步方法——锁是 **当前类的Class对象**。
   - **同步方法块**——锁是Synchronized**括号里配置的对象**。

2. Synchronized在JVM中的实现原理
   - monitorenter 和 monitorexit 互相搭配对应。
   - 对象头存放着锁：Mark Word（锁信息：分代年龄，偏向锁，锁标志位）

3. 锁的升级和对比
   - 无锁状态
   - 偏向锁状态
    > 偏向锁使用了一种等待竞争出现才释放锁的机制。用到了CAS
   - 轻量级锁状态
   - 重量级锁状态
  
| 锁      | 优点         |  缺点  | 适用场景 |
| :-----: | :--------:  | :----:  | :----:|
| 偏向锁   | 加锁和解锁不需要额外的消耗 |  竞争会带来额外的锁撤销的消耗  |一个线程访问同步块 |
| 轻量级锁 |  竞争线程不阻塞，提高响应速度  |  自旋消耗CPU  | 追求响应时间，同步块执行速度非常快|
| 重量级锁  | 线程竞争不用自旋锁，不消耗CPU |  线程阻塞，响应时间缓慢  | 追求吞吐量，同步块执行速度慢|

## 原子操作的实现原理

* 处理器如何实现原子操作
   >1. 使用总线锁保证原子性。
   >2. 使用缓存锁定来保证原子性。（不能缓存的数据无法使用；处理器不支持） 
* Java如何实现原子操作
   >1. 使用**循环CAS**实现原子操作
   >2. CAS会遇到的三大问题：
   >    - ABA问题（解决：使用版本号，后使用Atomic包的一个类AtomicStampedReference来解决）
   >    - 循环时间长开销大（解决：pause指令）
   >    - 只能保证一个共享变量的原子操作（用锁，或者合并变量、1.5后可以对对象保证原子性，多个变量放到对象里面）。
   >3. 使用**锁机制**实现原子操作（偏向锁、轻量级锁、互斥锁，后两个都是用CAS的方式来获取和释放锁）


# 三、Java内存模型

**并发编程模型的两个关键问题**：

1. 线程之间如何通信
   - 共享内存
   - 消息传递
2. 线程之间如何同步
   - 同步：程序中用于控制不同线程间操作发生的相对顺序的机制。







# 《Java线程与并发编程实战》

## Thread 和 Runnable

- 创建Runnable对象的方式：
1. 匿名类：
    ``` java
    Runnable r = new Runnable(){
      @Override
      public void run(){
        //do something
      }
    }
    ```  
2. lambda表达式：
   ``` java 
    Runnable r = () -> do something ;
   ```

- 创建Runnable对象之后，把它传递到Thread类接受Runnable作为参数的构造函数中。
  ``` java
  Thread t = new Thread(r);
  ```

- 获取和设置线程的名称
  - `getName()`
  - `Thread t1 = new Thread(r,"name")` 或者 `t2.setName("name")`

- 获取一条线程的存活状态： `boolean t.isAlive()`
- 获取一条线程的执行状态： `t.getState()` 
  - NEW
  - RUNNABLE
  - BLOCKED 阻塞并 等待一个监听锁
  - WAITING 无限期等待另外一个线程执行特定的操作
  - TIMED_WAITING 在特定时间内 等待另外一个线程执行特定操作
  - TERMINATED 线程已经退出

- 获取和设置线程的优先级
  - `getPriorrity()`
  - `setPriority`
  - 优先值介于Thread.MIN_PRIORITY 和 MAX_PRIORITY之间。

- 获取和设置线程的守护线程状态： `boolean isDaemon()`
  - `t.setDaemon(true)`
  - 定义：守护线程为非守护经常服务的，并且应用程序最后一条非守护线程消失之后自动死亡。

- 启动线程：`t.start()`
  - 调用`start()`方法会在运行时创建底层线程，通知调度run()方法中的指令。当run()方法执行完毕，线程就会被销毁，调用start()方法的Thread对象不再可用。

## 操作更高级的线程任务
 1. 中断线程
 2. 等待线程
 3. 线程睡眠