# Go 入门
## 简单介绍
Go 语言起源 2007 年，并于 2009 年正式对外发布。谷歌团队整的吧。
三个主要开发者：
- Robert Griesemer，参与开发 Java HotSpot 虚拟机；
- Rob Pike，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言；
- Ken Thompson，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范。

### 为什么要创造这门新语言？
在 Go 语言出现之前，开发者们总是面临非常艰难的抉择，究竟是使用执行速度快但是编译速度并不理想的语言（如：C++），还是使用编译速度较快但执行效率不佳的语言（如：.NET、Java），或者说开发难度较低但执行速度一般的动态语言呢？显然，Go 语言在这 3 个条件之间做到了最佳的平衡：快速编译，高效执行，易于开发。

### Go语言的特点和优势
- Go 语言的主要目标是将静态语言的安全性和高效性与动态语言的易开发性进行有机结合，达到完美平衡，从而使编程变得更加有乐趣，而不是在艰难抉择中痛苦前行。
- 有指针，但是不允许指针运算
- Go 语言的另一个目标是对于网络通信、并发和并行编程的极佳支持，从而更好地利用大量的分布式和多核的计算机。设计者通过 goroutine 这种轻量级线程的概念来实现这个目标，然后通过 channel 来实现各个 goroutine 之间的通信。他们实现了分段栈增长和 goroutine 在线程基础上多路复用技术的自动化
- Go 语言中另一个非常重要的特性就是它的构建速度（编译和链接到机器代码的速度），一般情况下构建一个程序的时间只需要数百毫秒到几秒。作为大量使用 C++ 来构建基础设施的谷歌来说，无疑从根本上摆脱了 C++ 在构建速度上非常不理想的噩梦。
- 具有严格的、简洁的依赖关系分析系统从而能够快速编译的编程语言。这正是 Go 语言采用包模型的根本原因，这个模型通过严格的依赖关系检查机制来加快程序构建的速度，提供了非常好的可量测性。

- 整个 Go 语言标准库的编译时间一般都在 20 秒以内，其它的常规项目也只需要半秒钟的时间来完成编译工作。使得程序的构建过程变得微不足道，拥有了像脚本语言和动态语言那样的高效开发的能力。

- Go 语言在执行速度方面也可以与 C/C++ 相提并论。

- 实现高效快速的垃圾回收（使用了一个简单的标记-清除算法）。

- Go 语言还能够在运行时进行反射相关的操作。

- 使用 go install 能够很轻松地对第三方包进行部署。

还有：
- 因为 Go 语言没有类和继承的概念，所以它和 Java 或 C++ 看起来并不相同。但是它通过接口（interface）的概念来实现多态性。Go 语言有一个清晰易懂的轻量级类型系统，在类型之间也没有层级之说。因此可以说这是一门混合型的语言。
- 函数是 Go 语言中的基本构件。
- 静态类型、强类型语言，隐式的类型转换是不被允许的，记住一条原则：让所有的东西都是显式的。Go 语言其实也有一些动态语言的特性（通过关键字 var）。
- Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。
- 因为垃圾回收和自动内存分配的原因，Go 语言不适合用来开发对实时性要求很高的软件

### Go语言的一些性能缺失（相对于其他语言的区别）
- 为了简化设计，不支持函数重载和操作符重载
- 为了避免在 C/C++ 开发中的一些 Bug 和混乱，不支持隐式转换
- Go 语言通过另一种途径实现面向对象设计（第 10-11 章）来放弃类和类型的继承
- 尽管在接口的使用方面（第 11 章）可以实现类似变体类型的功能，但本身不支持变体类型
- 不支持动态加载代码
- 不支持动态链接库
- 不支持泛型
- 通过 recover 和 panic 来替代异常机制（第 13.2-3 节）
- 不支持静态变量

## 一些需要避开的坑
参考文献：[Golang 需要避免踩的 50 个坑](https://juejin.im/post/5cad92e8f265da036d79a11f?utm_source=gold_browser_extension)
1. 左大括号 { 一般不能单独放一行
2. 未使用的变量编译会报错，全局变量可以声明不使用
3. 未使用的 import也会报错，可以使用 _ "fmt" 作为别名忽略导入的包
4. 简短声明的变量只能在函数内部使用
   ``` go
   //下面的声明形式只能放到函数当中。
    myvar := 1	//non-declaration statement outside function body
    func main() {
    }
   ```
5. 使用简短声明来重复声明变量
   > := 左侧至少有一个新变量，才允许多变量的重复声明
   ```go
   func main() {
	one := 0
	one, two := 1, 2 // two是新变量，允许one的重复声明。比如 error经常用同名变量 err
	one, two = two, one	// 交换两个变量值的简写
    }
   ```


## 调试和格式化

如果你不想使用调试器，你可以按照下面的一些有用的方法来达到基本调试的目的：

1. 在合适的位置使用打印语句输出相关变量的值（print/println 和 fmt.Print/fmt.Println/fmt.Printf）。
2. 在 fmt.Printf 中使用下面的说明符来打印有关变量的相关信息：
    - %+v 打印包括字段在内的实例的完整信息
    - %#v 打印包括字段和限定类型名称在内的实例的完整信息
    - %T 打印某个类型的完整说明
3. 使用 panic 语句（第 13.2 节）来获取栈跟踪信息（直到 panic 时所有被调用函数的列表）。
4. 使用关键字 defer 来跟踪代码执行过程（第 6.4 节）。

**格式化**：

- 在命令行输入 `gofmt –w program.go` 会格式化该源文件的代码然后将格式化后的代码覆盖原始内容（如果不加参数 -w 则只会打印格式化后的结果而不重写文件）；
- `gofmt -w *.go` 会格式化并重写所有 Go 源文件；
- `gofmt map1` 会格式化并重写 map1 目录及其子目录下的所有 Go 源文件。
