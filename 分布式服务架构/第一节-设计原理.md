## 1.1 从传统单体架构到服务化架构
### 1.1.1 JEE架构
三个层级： Web层、业务逻辑层、数据存取层。

JEE平台将不同的模块化组件聚合后，**运行在通用的应用服务器上**,例如：
> WebLogic、WebSphere，JBoss，也包括Tomacat（是仅实现了JEE Web规范的Web容器）。

JEE平台是典型的二八原则的一个应用场景：80%的与业务无关的逻辑和流程，**封装在应用服务器的模块化组件里**，**通过配置的模式**提供给应用程序访问。例如：
> 对象关系映射服务、数据持久化服务、事务服务、安全服务、消息服务等，通过简单配置即可子啊应用程序中使用。

三层团队：UI交互团队，后端服务研发团队，ORM、DBA团队；

其实已经很多耦合了，而且企业级应用，面向用户少，一般项目还是部署在同一台应用服务器上，并跑在一个JVM进程中。

### 1.1.2 SSH架构

**起因**：EJB笨重，难以做单元测试，学习曲线太高。

**开源软件**：Struts、Spring、Hibernate。 SSH开始崭露头角。

MVC框架：模型、视图、控制器。 Struts开始的，后来Spring更加简单、方便又灵活。

**Spring**：两个核心思想：IOC和AOP。

**IOC**：控制反转。**将传统的EJB基于容器的开发**改造成**普通的Java组件的开发**，运行时由Spring容器进行统一管理和串联，在开发过程中**对Spring容器没有强依赖**，**便于开发**、**测试**、**验证和迁移**，EJB依赖于多个容器接口，还需要复杂的XML配置，测试要依赖，需要重启重型容器来测试。

**AOP**：面向切面的编程，适用于面向对象方法无法抽象的业务逻辑，例如：
> 日志、安全、事务、应用程序性能管理（APM）等。

AOP的实现方式：

1. 对Java字节码进行从新编译，将切面插入字节码的某些点和面上，可以使用cglib库实现。
2. 定制类加载器，在类加载时对字节码进行补充，同上，JVM自身提供的Java Agent机制就是在加载类的字节码时，通过增加切面来实现AOP。
3. JVM本身提供了**动态代理组件**，可以通过它实现任意对象的代理模式，在代理的过程中可以插入切面的逻辑。使用APIProxy.newProxyInstance()和InvocationHandler来实现。
4. 另外AspectJ是实现AOP的专业框架和平台。

UI交互层有Struts；业务逻辑层有Spring；那么 还差个对象关系映射： Hibernate。

**Hibernate**：减少应用层开发人员写SQL的时间，不过高度抽象的ORM框架被证明存在性能瓶颈，后来大家更倾向于使用**更加灵活的MyBatis**来实现ORM层。

不过还是基本集合在一个Web容器中，如Tomcat。业务逻辑还是耦合在一个项目中。

### 1.1.3 服务化架构

之前的都是单体化，现在变成服务化。

SOA：面向服务的架构。有如下特点：

1. 定义了良好的对外接口，通过网络协议对外提供服务，服务之间松耦合性，更灵活。
2. 组成整个业务流程的每个服务内部结构和实现改变不会影响对外提供的服务，只要对外接口保持不变，改变内部实现机制，对外部来说是透明的。
3. 当时主要数据通信格式是XML，不过太冗余了，现在基本用JSON。
4. SOA通过定义标准的对外接口，可以让底层通用服务进行下层，供多个上层的使用方同时使用，增加了服务的可重用性。
5. 可以让企业最大化的使用内部和外部的公共服务，不用重复造轮子。例如从外部获取时间服务。

**两个主流实现方式**：

1. **Web Service**:多个服务之间是对等的，通过WSDL、UDDI注册服务（到目录服务中），SOAP协议进行通信（在HTTP通道上传输XML数据来实现的协议），但每个服务都要依赖中心化Web Service目录来发现现存的服务。
2. **ESB**：企业服务总线，用于设计和实现网络化服务交互和通信的软件模型。主要用于企业信息化系统的集成服务场景，Mule是ESB的一个实现。
>同时ESB也适用于事件处理、数据转换和映射、消息和事件异步队列顺序处理、安全和异常处理、协议转换、和保证通信服务的质量等场景。
> **核心在于企业服务总线的功能和职责**：  
> * 监控和控制服务之间的消息路由。
> * 控制可插拔的服务化功能和版本。
> * 解析服务之间交互和通信的内容。
> * 通过组合服务、资源和消息处理来统一编排业务需要的信息处理流程。
> * 使用冗余来提供服务的备份能力。

## 1.2 从服务化到微服务

### 1.2.1 微服务架构的产生

**之前的服务化架构有问题**：

1. Web Service:依赖中心化的服务发现进制；使用SOAP通信协议，XML格式序列化通信数据，太冗余太大；服务化管理和智力设施不完善。
2. ESB：更多的体现了系统集成的便利性而已；组合到它身上的服务太重，；用总线去因此内部复杂性，但是复杂又还是存在； 对于总线本身的中心化管理模型，牵一发动全身。

**微服务**：倡导将软件应用设计成——**多个可独立开发、可配置**、**可运行和可维护的子服务**，子服务之间通过良好的接口定义通信（通常使用**RESTful**风格的**API形式**，也可以通过**底层的二进制协议、消息队列协议**），不需要中心化的统一管理。

**松耦合、高内聚**，这个概念在UNIX系统中的 **管道概念**早有体现，它负责微服务之间的交互通信。

### 1.2.2 微服务架构与传统架构的对比

**微服务**：
* 微服务把单一职责单一的功能放在一个独立的服务中；
* 每个服务运行在单一的进程中；
* 每个服务有多个实例，每个实例可以运行在容器化平台中，达到平滑伸缩的效果；
* 每个服务有自己的数据存储（应该有自己独享的数据库、缓存、消息队列等资源）；
* 每个服务高度自治，内部变化对外透明；
* 可根据性能需求独立的进行水平伸缩。
  
**传统单体架构**：

* 所有模块化组件混合后运行在统一个服务JVM进程中；
* 可对包含多个模块化组件的整体JVM进程进行水平扩展，而无法对某个模块化组件进行水平扩展
* 某个模块化组件发生变化，需要所有模块化组件进行编译、打包和上线
* 长此以往，模块之间依赖会不清晰、耦合依赖增多。
  
### 1.2.3 微服务架构与SOA服务化对比

一脉相承，很多设计模式和解决方案都适用于两种；略有不同：

目的不同：
* SOA服务化范围更广一些，强调异构服务之间协作，有效集成、业务流程编排等
* 微服务：一些列小服务实现整体业务，拆分应用，敏捷开发和部署，团队细化分工，缩小变更迭代的影响范围，更容易水平扩展。 
  
部署方式不同：

* 微服务：完整应用拆成小服务，通常用Docker实现自动化容器管理，互相独立、互不影响。
* SOA服务化：将多个业务服务通过组件化模块方式打包在一个War包，统一部署到一个应用服务器上。

服务粒度不同：

* 微服务细粒度，职责单一。
* SOA粗粒度，强调接口契约规范化。


### 1.3.4 微服务的分解和组合模式

1. 以什么方式组合微服务？
 * 服务代理模式
 * 服务聚合模型
 * 服务串联模式  ——只要不是在正后面增加节点，串联服务无感知
 * 服务分支模式  ——前面的混合模式，分支服务可以拥有自己的数据库存储
   > 如果调用链有多个层次重复了基础服务，那基础服务挂掉一部分，对整体流量影响是叠加的。
 * 服务异步消息模式  上面的都是同步的RESTful风格的同步调用实现，是阻塞的，多了撑满服务线程池——雪崩效应。我们异步就不是，（核心链路用同步，次要的就异步）可通过消息队列将异步消息传递给次要服务。
 * 服务共享数据模式 ——反模式，之前都是去数据共享，解耦，专业做专业。然而有下面两种场景需要这个模式：
    
    1. 单元化架构。减少网络通信带来的性能损耗。
    2. 遗留的整体服务。
   除了这两个之外，都不要用这模式。

### 1.3.5 微服务的容错模式
 