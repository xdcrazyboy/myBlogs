
# 内存管理

## Java内存的分配策略

Java 程序运行时的内存分配策略有三种,分别是**静态分配**,**栈式分配**,和**堆式分配**，对应的，三种存储策略使用的内存空间主要分别是静态存储区（也称方法区）、栈区和堆区。

- **静态存储区（方法区）**：主要存放**静态数据**、**全局static数据**和**常量**。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。

- **栈区** ：**线程私有**。当方法被执行时，**方法体内的局部变量**（其中包括基础数据类型、**对象的引用**）都在栈上创建，并在方法执行结束时这些局部变量所持有的内存将会**自动被释放**。因为栈内存分配运算内置于处理器的**指令**集中，效率很高，但是分配的内存**容量有限**。

- **堆区**： 又称**动态内存分配**，通常就是指在程序运行时直接 new 出来的内存，也就是**对象的实例**。这部分内存在不使用时将会由 Java 垃圾回收器来负责回收。

## 栈
### Java虚拟机栈
**线程私有的**，它的生命周期跟线程相同。
* 每个方法的调用到完成，其实就是对应一个**栈帧**在虚拟机栈中出栈和入栈的过程。
* 虚拟机栈就是**执行Java方法的内存模型服务**：每个方法的执行时都会创建一个栈帧，用于存储：
    >  局部变量表、操作数栈、动态链接、方法出口等信息
    > 1. 局部变量表：存放编译期可知的各种**数据类型、对象应用、returnAddress类型**
    > 2. 操作数栈：大多数指令都要从这里：弹出数据，执行运算，把结果压回。
    > 3. 动态连接：每个栈帧都包含一个指向**运行时常量池**（方法区的一部分）中该帧**所属方法**的**引用**。
    > 4. 方法出口：返回方法被调用的位置，恢复上层方法的**局部变量**和**操作数栈**。类似递归时...
    > 
    > 局部表量表所需的内存空间在**编译期间**完成分配。 在方法运行期间不会改变局部变量表的大小。
* 虚拟机栈定义了两种异常：
    1. StackOverfloError：线程请求的**深度大于虚拟机所允许的深度**。
    2. OutOfMemoryError：虚拟机栈动态扩展时无法申请到足够的内存。

**本地方法栈比较**
1. 本地方法栈为虚拟机使用到**的Native方法**服务。 HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一。
2. 虚拟机栈为虚拟机**执行Java方法（也就是字节码）**服务；本地方法栈则为虚拟机使用到的Native方法服务。

## Java堆
Java Heap： 一般是最大的一块管理内存区域。是被所有线程 **共享的**一块内存区域。

目的：**存放对象实例**，还有**数组**。

Java堆是垃圾收集器管理的主要区域，所以也叫GC堆，细分为：Eden空间、From Survivor空间、To Survivor空间。

可以处于物理上不连续的内存空间，只要逻辑上连续即可。

## 方法区
**线程共享**，用于存储**已被虚拟机加载的类信息、常量、静态变量、运行时常量池**、即时编译后的代码，方法区也叫：**持久代**（Permanent Generation），Non-Heap（非堆）。因为它存放的信息与垃圾回收关系不大，可以**选择不实现垃圾回收**。

方法区的内存回收主要针对：**常量池的回收**和**类的卸载**。

**运行时常量池**：
* jdk1.7之后，字符串常量池已经从方法区挪到堆中了。
* 对比下，常量池：常量池数据编译期被确定，是Class文件中的一部分，存储了类、方法、接口等中的**常量**，也包括字符串常量。
* 运行时常量池：方法区的一部分，所有线程共享。虚拟机加载Class后把常量池中的数据放入**运行时常量池**。



### 内存泄露

**什么是内存泄露？**
> 指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 出现**可达、无用的对象**。

**如何导致的？**

长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是Java中内存泄漏的发生场景

1. 单例造成的内存泄漏
2. 非静态内部类创建静态实例造成的内存泄漏
> 解决办法：将该内部类设为静态内部类或将该内部类抽取出来封装成一个单例，如果需要使用Context，就使用Application的Context。
3. Handler造成的内存泄漏
> 解决办法：将Handler类独立出来或者使用静态内部类，这样便可以避免内存泄漏。
jishi程造成的内存泄漏
> 解决办法： 将AsyncTask和Runnable类独立出来或者使用静态内部类，这样便可以避免内存泄漏。
5. 资源未关闭，监听器未关闭。

**怎么解决？**

1.  * 将内部类改为静态内部类
    * 静态内部类中使用弱引用来引用外部类的成员变量

2. 尽量避免使用 static 成员变量

# GC
