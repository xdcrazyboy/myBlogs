# 账户/地址

公钥公开，然后地址是通过公钥进行两次hash（先进行SHA256/HASH160，然后进行RIPEMD160），最后进行编码运算后生成 160位（20个字节）的字符串。

为什么不直接用公钥作为地址？ 有一种考虑是，避免公钥过早公开后导致被破解出私钥。

# 交易

交易包含的信息：
- 付款人地址
- 付款人对交易的签字确认
- 付款人资金的来源交易ID
- 交易的金额
- 收款人地址
- 收款人的公钥
- 时间戳：交易何时生效。

网络节点收到交易信息后，需要做的检查：
- 交易是否已经处理
- 交易是否合法：
  - 地址是否合法
  - 发起交易者是否是输入地址的合法拥有者
  - 是否是UTXO

- 交易的输入之和是否大于输出之和

如果检查通过，则将交易标记为合法的未确认交易，并在网络内进行广播。

# 交易脚本
脚本（script）是保障交易完成的核心机制，主要用于检验交易是否合法，当所依附的交易发生时被触发。通过脚本机制而非写死交易过程，比特币网络实现了一定的可扩展性。不过是图灵不完备的，还是有很大局限性。

分为输出脚本和认领脚本

## 输出脚本

一般由付款方对交易设置锁定，用来对动用这笔交易输出的对象（收款方）进行权限控制，比如限制必须是某个公钥的拥有者才能花费这笔交易。 
目前支持两种类型：

- P2PKH：Pay-To-Public-Key-Hash,允许用户将比特币发送到一个或者多个典型的比特币地址上，前导字节一般为 `0x00`；
- P2SH：Pay-To-Script-Hash,支付者创建一个输出脚本，里边包含另一个脚本（认领脚本）的哈希，一般用于需要多人签名的场景，前导字节一般为`0x05`。

例子：
```shell 
//复制栈顶元素 然后计算<pubKeyHash>的哈希值，对比这两个值，判断签名是否合法.——>保证只有pubKey的拥有者才能合法引用这个输出
scriptPubKey: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECHSIG
```

## 认领脚本

认领脚本则用来证明自己可以满足交易输出脚本的锁定条件，即对某个交易的输出的拥有权。

入栈依次处理，并非图灵完备，并且还会限制大小。

# 区块

- 区块大小(4字节，后同单位)
- 区块头（80）
  - 版本号（4）
  - 上一个区块头的SHA256 Hash值：链接到一个合法的块上。（32）
  - 时间戳（4）
  - 难度指标（4）
  - Nonce（4）
- 交易个数计数器（1~9）
- 所有交易的具体内容，可变长。

可见，对区块链完整性进行检查，只需要检验各个区块头信息即可，所有有 简单交易验证 SPV，而头部链接，环环相扣，牵一发动全身，就是提供时序关系的同时较大了对区块中数据穿篡改的难度。